MobileAutomationFramework/
├── .github/                # [CI/CD] GitHub Actions 工作流
│   └── workflows/
│       └── ci.yml          # 配置代码提交时自动运行 pylint 检查或单元测试
├── .gitignore              # [Git配置] 忽略 logs/, reports/, __pycache__/, .env 等
├── .env.example            # [环境模板] 告诉使用者需要配置哪些环境变量 (如 USERNAME=xxx)
├── Dockerfile              # [容器化] (可选) 用于构建纯净的 Python 运行环境
├── LICENSE                 # [开源协议] MIT 或 Apache 2.0，声明版权
├── README.md               # [项目说明] 架构图、快速开始、贡献指南
├── requirements.txt        # [依赖列表] Appium-Python-Client, pytest, allure-pytest, loguru
├── pytest.ini              # [Pytest配置] addopts = -vs --alluredir=./reports/xml
└── run.py                  # [入口脚本] 统一执行入口，处理参数解析

配置与数据层
├── config/
│   ├── __init__.py
│   ├── global_config.py    # [全局配置] URL, BundleID, 等待超时时间
│   └── logging_config.py   # [日志设置] 格式化器、文件轮转配置
├── data/
│   ├── __init__.py
│   ├── test_accounts.yaml  # [账号池] 存放多角色测试账号
│   └── test_data.xlsx      # [测试数据] 参数化用例的数据源

驱动管理层
├── drivers/
│   ├── __init__.py
│   └── driver_factory.py   # [Driver工厂]
                            # 功能：封装 Android/iOS/H5 的 Desired Capabilities
                            # 职责：负责 Appium 连接建立与 quit 销毁

页面对象层 (Layer 1: Pages)
├── pages/
│   ├── __init__.py
│   ├── base_page.py        # [核心基类]
                            # 功能：Find, Click, Input, Screenshot, SwitchContext(H5)
                            # 继承：ActionMixin
│   ├── mixins/             # [功能混入]
│   │   ├── __init__.py
│   │   └── action_mixin.py # [W3C动作] 封装 Swipe, LongPress, DragAndDrop, Pinch
│   ├── android/            # [Android页面]
│   │   ├── __init__.py
│   │   ├── home_page.py
│   │   ├── login_page.py
│   │   └── webview_page.py # [H5专用] 处理内嵌 Webview 的特殊页面
│   └── ios/                # [iOS页面]
│       └── ...

业务流程层 (Layer 2: Workflows)
├── workflows/
│   ├── __init__.py
│   ├── base_workflow.py    # [Workflow基类]
                            # 功能：持有 driver，按需懒加载 Page 对象，避免重复实例化
│   ├── login_flow.py       # [登录业务] 组装：输入账号 -> 点击登录 -> 校验失败/成功
│   ├── post_flow.py        # [内容业务] 组装：进入发布页 -> 选图 -> 发送
│   └── h5_flow.py          # [混合业务] 原生入口 -> 切换H5 -> 操作网页 -> 切回原生

测试用例层 (Layer 3: TestCases)
├── testcases/
│   ├── __init__.py
│   ├── conftest.py         # [Pytest Fixture]
                            # Setup: 启动 Appium Driver
                            # Teardown: 关闭 Driver
                            # Hook: 失败自动截图并挂载到 Allure 报告
│   ├── test_login.py       # [功能测试] 验证登录模块
│   └── test_scenarios.py   # [场景测试] 跨账号、长链路的 E2E 测试

工具层 (Utils)
├── utils/
│   ├── __init__.py
│   ├── adb_helper.py       # [系统交互] 封装 ADB 命令 (清理缓存, 切换输入法)
│   ├── assert_helper.py    # [高级断言] 软断言、字典对比、列表排序校验
│   ├── cv_helper.py        # [图像识别] OpenCV 封装 (用于无法定位的控件)
│   ├── data_loader.py      # [数据读取] 解析 YAML/Excel/JSON
│   ├── file_helper.py      # [文件操作] 路径拼接、文件夹清理
│   ├── logger.py           # [日志封装] 二次封装 logging 或 loguru，提供简便调用接口
│   ├── notify_helper.py    # [消息通知] 飞书/钉钉 Webhook 封装
│   └── decorators.py       # [装饰器]
                            # @log_step: 记录步骤
                            # @handle_exception: 异常捕获

产出物 (Artifacts - 需在 .gitignore 中忽略)
├── reports/                # Allure XML/HTML 报告
├── logs/                   # 运行时产生的 .log 文件
└── screenshots/            # 失败截图或业务截图


1. pages/base_page.py —— 核心交互层
这是所有页面的“父亲”，它必须解决稳定性和通用性问题。

建议包含的方法列表：
初始化与基础

__init__(self, driver): 初始化 Driver，设置默认显式等待时长（如 10秒）。

_find_element(locator): (核心) 封装 WebDriverWait + EC.presence_of_element_located。所有后续操作都调用它，统一处理“找不到元素”的异常。

_find_elements(locator): 获取元素列表。

常用操作 (各类封装)

click(locator): 等待元素可见且可点击 (element_to_be_clickable) 后再点击。防止点击过快报错。

input_text(locator, text): 逻辑应为：find -> click (激活焦点) -> clear (清空) -> send_keys。

get_text(locator): 获取元素文本。注意兼容：有的元素文本在 text 属性，有的在 content-desc。

get_attribute(locator, attr_name): 获取属性（如 checked, enabled, resource-id）。

is_element_exist(locator, timeout=3): (布尔值) 用于断言或判断流程分支。设置较短的 timeout，找不到返回 False，不要抛异常。

环境与调试

get_screenshot(filename): 保存截图到指定目录。

get_page_source(): 打印当前页面源码（调试定位神器）。

switch_to_webview() / switch_to_native(): (之前讨论过的 Context 切换)。

特殊处理

handle_system_popup(): 处理系统权限弹窗（如“允许访问位置”）。虽然通常用 watcher 处理，但在 BasePage 里留一个手动处理的方法很实用。

2. pages/mixins/action_mixin.py —— W3C 动作扩展
Appium 新版本强推 W3C Actions，以前的 TouchAction 已经被标记为过时。这里主要封装手势。

建议包含的方法列表：
滑动 (Swipe)

swipe_by_coordinates(start_x, start_y, end_x, end_y, duration): 最底层的滑动实现。

swipe_up(duration=1000): 屏幕宽度的 50%，从下(80%)滑到上(20%)。

swipe_down(): 下拉刷新常用。

swipe_left() / swipe_right(): 轮播图切换常用。

swipe_find_element(locator, max_swipes=5): (高级) 边滑边找，直到元素出现或达到最大次数。

高级手势

long_press_element(locator, duration=2000): 长按元素（触发删除、菜单等）。

tap_by_coordinates(x, y): 坐标点击（对付那些定位不到的 Native 控件或 H5 Canvas）。

drag_and_drop(source_loc, target_loc): 拖拽元素（如有排序功能）。

3. workflows/base_workflow.py —— 业务流管家
这一层不操作 UI，只管理 Page 的生命周期和 App 的生命周期。

建议包含的方法列表：
Page 管理

__init__: 初始化所有 Page 类。建议使用懒加载 (Lazy Loading) 模式（用到时再实例化），避免启动太慢。

App 生命周期管理

restart_app(): 重启应用（用于用例之间的环境清理）。

background_app(seconds): 模拟 Home 键切后台再回来（测试热启动 bug）。

terminate_app() / activate_app(): 杀进程/拉起进程。

物理按键模拟

press_back(): 模拟安卓物理返回键。

press_home(): 模拟 Home 键。

press_enter(): 模拟键盘回车（搜索时常用）。

4. utils/ 工具箱 —— 具体文件功能清单
这里是你框架的“瑞士军刀”，建议按功能拆分：

A. utils/adb_helper.py (Android 专属神器)
Appium 做不到或太慢的事情，用 ADB 做。

shell(command): 执行 ADB 命令的基础封装。

get_device_size(): 获取分辨率（供滑动计算用）。

switch_input_method(ime_id): (必做) 输入中文前切成 Appium 键盘，输完切回系统键盘（如搜狗/Gboard），否则手机键盘弹出会遮挡按钮。

clear_app_cache(package): 清理缓存。

is_keyboard_shown(): 判断键盘是否弹出。

push_file(local, remote) / pull_file(): 上传图片/下载日志。

B. utils/assert_helper.py (断言增强)
assert_element_visible(driver, locator): 元素可见断言。

assert_text_contains(full_text, keyword): 文本包含断言。

assert_list_is_sorted(list_data): 检查列表是否按时间/价格排序。

soft_assert(): (软断言) 即使失败了也不停止测试，最后统一报错（适合一次验证页面上几十个元素的场景）。

C. utils/file_helper.py (文件与路径)
get_project_root(): 获取项目根路径（防止相对路径 ../../ 到处飞）。

clean_dir(dir_path): 每次运行前清空 screenshots/ 或 reports/ 文件夹。

read_yaml(path): 读取配置。

D. utils/decorators.py (装饰器 - 提升逼格与实用性)
@log_step(message):

Python

@log_step("执行登录操作")
def login(self): ...
自动在日志里打印 [START] 执行登录操作 和 [END] 执行登录操作。

@screenshot_on_error: 如果方法抛出异常，自动截图。

@retry(times=3): 如果报错，自动重试 3 次（适合网络不稳定的场景）。

E. utils/image_helper.py (图像处理 - 选做)
crop_image(path, coordinate): 裁剪截图（用于验证码识别）。

compare_images(img1, img2): 对比两张图的相似度（OpenCVSSIM算法），用于 UI 走查。





# MobileAutomationFramework 核心层功能规划书

## 1. 文件：`pages/base_page.py`

**定位**：基础页面对象类
**职责**：负责单一元素交互、状态检查、系统环境操作。所有 Page 类均继承此类。

### A. 核心定位与交互 (Core Interactions)

| 方法名 | 参数 | 逻辑说明 (Vibe Coding Prompt) |
| --- | --- | --- |
| **`_find_element`** | `locator`, `timeout` | **[内部核心]** 封装 `WebDriverWait` 和 `expected_conditions`。所有后续方法必须调用此方法，统一处理异常和日志。 |
| **`click_element`** | `locator` | 等待元素**可见且可被点击** (Clickable) 后执行点击操作。 |
| **`input_text_direct`** | `locator`, `text` | **[直接输入]** 点击元素获取焦点 -> 直接 `send_keys` 追加内容（不执行清空）。 |
| **`input_text_clear`** | `locator`, `text` | **[标准输入]** 点击元素 -> 执行 `clear()` -> 输入内容 -> **检测键盘并收起** (Hide Keyboard)。 |
| **`get_text`** | `locator` | **[智能获取]** 优先读取 `text` 属性；如果为空，降级读取 `content-desc` 属性。 |
| **`get_element_attribute`** | `locator`, `attr_name` | 获取指定属性值 (如 `enabled`, `checked`, `resource-id`)。 |
| **`set_switch_status`** | `locator`, `status(bool)` | **[智能开关]** 获取当前 `checked` 状态。如果当前状态与目标 `status` 不一致，则点击；一致则跳过。 |

### B. 状态检查 (State Checks)

| 方法名 | 参数 | 逻辑说明 (Vibe Coding Prompt) |
| --- | --- | --- |
| **`is_element_exist`** | `locator`, `timeout=3` | **[布尔判断]** 设置较短超时。捕获 `TimeoutException` 不报错，存在返回 `True`，不存在返回 `False`。 |
| **`wait_for_element_disappear`** | `locator`, `timeout` | **[等待消失]** 使用 `invisibility_of_element_located`。常用于等待 Loading 遮罩结束。 |
| **`get_toast_message`** | `partial_text` | **[Toast捕获]** 使用 XPath `//*[@class='android.widget.Toast']` 查找。需快速定位。 |

### C. 系统与环境 (System & Context)

| 方法名 | 参数 | 逻辑说明 (Vibe Coding Prompt) |
| --- | --- | --- |
| **`switch_to_webview`** | `context_name` | **[H5切换]** 打印当前 Contexts。若未指定名称，自动切换到第一个包含 "WEBVIEW" 的 Context。 |
| **`switch_to_native`** | 无 | 强制切换回 `NATIVE_APP` Context。 |
| **`press_back`** | 无 | 模拟物理返回键 (Back Button)。 |
| **`press_keycode`** | `keycode(int)` | 发送 Android KeyCode (如 66=Enter, 67=Delete)。 |
| **`save_screenshot`** | `name_prefix` | 截图并保存到 `logs/screenshots/` 目录，文件名带时间戳。 |

---

## 2. 文件：`pages/mixins/action_mixin.py`

**定位**：动作能力扩展类 (Mixin)
**职责**：负责屏幕手势、多点触控、复合查找。
**技术要求**：**必须使用 Appium W3C Actions API** (`ActionChains`, `PointerInput`)，严禁使用旧版 `TouchAction`。

### A. 屏幕方向滑动 (Directional Swipe)

*注：此类滑动基于屏幕百分比坐标计算。*

| 方法名 | 参数 | 逻辑说明 (Vibe Coding Prompt) |
| --- | --- | --- |
| **`swipe_up`** | `duration=1000` | **[上滑/加载更多]** 从屏幕高度 80% 处滑向 20% 处 (X轴保持中心)。 |
| **`swipe_down`** | `duration=1000` | **[下滑/刷新]** 从屏幕高度 20% 处滑向 80% 处。 |
| **`swipe_left`** | `duration=1000` | **[左滑]** 从屏幕宽度 90% 处滑向 10% 处 (Y轴保持中心)。 |
| **`swipe_right`** | `duration=1000` | **[右滑/返回]** 从屏幕宽度 10% 处滑向 90% 处。 |

### B. 精确坐标操作 (Precision Actions)

| 方法名 | 参数 | 逻辑说明 (Vibe Coding Prompt) |
| --- | --- | --- |
| **`swipe_by_coordinates`** | `start_x`, `start_y`, `end_x`, `end_y`, `duration` | **[任意滑动]** 使用 `W3C ActionBuilder` 执行 Pointer Move -> Down -> Pause -> Move -> Up。 |
| **`tap_by_coordinates`** | `x`, `y` | **[盲点]** 点击指定像素坐标 (Pointer Down -> Pause(0.1s) -> Up)。 |

### C. 高级手势 (Advanced Gestures)

| 方法名 | 参数 | 逻辑说明 (Vibe Coding Prompt) |
| --- | --- | --- |
| **`long_press_element`** | `locator`, `duration=2000` | **[长按]** 定位元素 -> 移动至元素中心 -> 按下 -> **停顿指定时长** -> 抬起。 |
| **`zoom_in`** | `percent` | **[双指放大]** 定义两个 PointerInput (Finger1, Finger2)。从屏幕中心同时向上下反向移动。 |
| **`zoom_out`** | `percent` | **[双指缩小]** 定义两个 PointerInput。从屏幕外侧向中心移动。 |

### D. 复合查找 (Composite Actions)

*注：此类方法包含逻辑循环，不包含断言。*

| 方法名 | 参数 | 逻辑说明 (Vibe Coding Prompt) |
| --- | --- | --- |
| **`swipe_until_element_appear`** | `locator`, `max_swipes`, `direction` | **[滑动找元素]** <br>

<br>1. 循环 `max_swipes` 次。<br>

<br>2. 每次循环先调用 `is_element_exist(timeout=1)`。<br>

<br>3. 若存在直接返回 Element。<br>

<br>4. 若不存在，根据 `direction` 执行一次滑动，等待惯性结束。 |
| **`swipe_until_text_appear`** | `text`, `max_swipes`, `direction` | **[滑动找文字]** <br>

<br>1. 内部构造 XPath: `//*[contains(@text, 'text') or contains(@content-desc, 'text')]`。<br>

<br>2. 调用 `swipe_until_element_appear`。 |



# 文件：`workflows/base_workflow.py`

**定位**：业务流基类
**职责**：依赖注入 (Driver)、页面对象管理 (Page Registry)、App 级操作 (Lifecycle)。

### A. 初始化与页面管理 (Init & Page Registry)

*核心设计模式：使用 `@property` 实现懒加载 (Lazy Loading)，避免在测试开始时一次性初始化所有页面，节省内存并提高启动速度。*

| 方法名 | 参数 | 逻辑说明 (Vibe Coding Prompt) |
| --- | --- | --- |
| **`__init__`** | `driver` | 1. 接收并存储 `self.driver`。<br>

<br>2. 初始化私有变量 (如 `self._home_page = None`) 用于后续懒加载。 |
| **`home_page`** (Property) | 无 | **[属性]** 判断 `self._home_page` 是否为空。若为空，实例化 `HomePage(self.driver)` 并赋值；若不为空，直接返回。 |
| **`login_page`** (Property) | 无 | **[属性]** 同上，实例化 `LoginPage`。 |
| **`webview_page`** (Property) | 无 | **[属性]** 同上，实例化 `WebviewPage` (用于 H5 操作)。 |
| **`...`** | 无 | **[扩展]** 后续每新增一个 Page，都需要在这里注册一个对应的 Property。 |

### B. App 生命周期管理 (App Lifecycle)

*这些操作是针对 App 整体的，不是针对某个页面的，所以放在 Workflow 基类最合适。*

| 方法名 | 参数 | 逻辑说明 (Vibe Coding Prompt) |
| --- | --- | --- |
| **`restart_app`** | 无 | **[重启应用]** 调用 `driver.terminate_app(app_id)` 然后 `driver.activate_app(app_id)`。用于保证下一个用例在纯净环境下运行。 |
| **`background_app`** | `seconds` | **[切后台]** 调用 `driver.background_app(seconds)`。模拟用户按 Home 键切出去再回来的场景（测试热启动或状态保存）。 |
| **`close_app`** | 无 | **[杀进程]** 调用 `driver.terminate_app(app_id)`。 |
| **`launch_app`** | 无 | **[冷启动]** 调用 `driver.activate_app(app_id)`。 |

### C. 全局物理按键 (Global Hardware Keys)

*虽然 `BasePage` 也有这些能力，但在 Workflow 层暴露出来，写业务流时会更流畅（不用特意调 `self.home_page.press_back()`）。*

| 方法名 | 参数 | 逻辑说明 (Vibe Coding Prompt) |
| --- | --- | --- |
| **`press_back`** | 无 | **[物理返回]** 模拟点击手机物理返回键。 |
| **`press_home`** | 无 | **[物理Home]** 模拟点击手机 Home 键。 |
| **`press_enter`** | 无 | **[物理回车]** 模拟点击键盘的回车键（搜索/发送）。 |

### D. 流程辅助 (Flow Helpers)

| 方法名 | 参数 | 逻辑说明 (Vibe Coding Prompt) |
| --- | --- | --- |
| **`wait_seconds`** | `seconds`, `msg` | **[强制等待]** 封装 `time.sleep(seconds)`。**必须添加日志记录**（如 `logger.info(f"等待 {seconds} 秒: {msg}")`），让强制等待有迹可循。 |



### 文件：`testcases/conftest.py`

#### A. 命令行选项与配置 (CLI Options)

*负责让你的测试脚本支持参数化运行。*

| 函数名 | 参数 | 逻辑说明 (Vibe Coding Prompt) |
| --- | --- | --- |
| **`pytest_addoption`** | `parser` | **[Pytest Hook]** 注册自定义命令行参数。<br>

<br>1. `--env`: 指定运行环境 (test/prod)，默认 test。<br>

<br>2. `--platform`: 指定运行平台 (android/ios)，默认 android。<br>

<br>3. `--browser`: (可选) 是否启动 Webview 模式。 |
| **`cmdopt`** | `request` | **[Fixture]** 简单的 fixture，用于将上述参数的值解析出来，以字典形式返回给其他 fixture 使用 (如 `{'env': 'test', 'platform': 'android'}`)。 |

#### B. Driver 生命周期管理 (Driver Lifecycle)

*这是整个自动化最关键的 Fixture。*

| 函数名 | 参数 | 逻辑说明 (Vibe Coding Prompt) |
| --- | --- | --- |
| **`driver`** | `request`, `cmdopt` | **[核心 Fixture]** `scope='function'` (建议每用例重启，保证独立性) 或 `'class'`。<br>

<br>**Setup 阶段:**<br>

<br>1. 获取 `cmdopt` 中的配置。<br>

<br>2. 调用 `drivers.driver_factory.DriverFactory.get_driver(...)` 初始化 Driver。<br>

<br>3. **关键步骤**: 执行 `request.cls.driver = driver`。这一步是将 driver 注入到测试类中，让 TestLogin 里的 `self.driver` 有值。<br>

<br>4. `yield driver` (测试开始执行)。<br>

<br>

<br>**Teardown 阶段:**<br>

<br>1. 执行 `driver.quit()` 关闭应用。<br>

<br>2. 记录 "Driver closed" 日志。 |

#### C. 失败钩子与截图 (Hooks & Screenshots)

*负责“出了事留证据”。*

| 函数名 | 参数 | 逻辑说明 (Vibe Coding Prompt) |
| --- | --- | --- |
| **`pytest_runtest_makereport`** | `item`, `call` | **[Pytest Hook]** 拦截测试执行结果。<br>

<br>1. 判断 `call.excinfo` 是否存在（即是否有异常抛出）。<br>

<br>2. 如果 `report.when == 'call'` 且 `report.failed == True` (测试失败)：<br>

<br>3. 从 `item` 中获取 driver 实例 (通常通过 `item.instance.driver` 或 `item.funcargs['driver']`)。<br>

<br>4. 调用 `_capture_screenshot` 函数。<br>

<br>5. 将截图附加到 Allure 报告中。 |
| **`_capture_screenshot`** | `driver`, `name` | **[内部助手]** <br>

<br>1. 调用 `driver.get_screenshot_as_png()`。<br>

<br>2. 使用 `allure.attach()` 将二进制图片数据贴到报告里，命名为 `failure_timestamp`。<br>

<br>3. (可选) 同时保存一份到本地 `logs/screenshots/` 目录备份。 |

#### D. 环境信息收集 (Allure Environment)

*让报告看起来更专业，显示是在什么手机、什么环境下跑的。*

| 函数名 | 参数 | 逻辑说明 (Vibe Coding Prompt) |
| --- | --- | --- |
| **`pytest_configure`** | `config` | **[Pytest Hook]**<br>

<br>1. 运行开始前，读取 `global_config`。<br>

<br>2. 写入 Allure 的 Environment Info (如 App Version, Base URL, Platform)。<br>

<br>这样生成的 Allure 报告首页就会显示环境参数。 |



### 文件：`utils/adb_helper.py`

#### A. 基础执行器 (Base Executor)

*所有 ADB 方法的底层入口，处理命令拼接和编码问题。*

| 函数名 | 参数 | 逻辑说明 (Vibe Coding Prompt) |
| --- | --- | --- |
| **`execute_adb_command`** | `cmd`, `device_id=None` | **[底层封装]**<br>

<br>1. 接收 ADB 子命令 (如 `shell pm list`)。<br>

<br>2. 拼接完整命令：`adb -s {device_id} {cmd}`。<br>

<br>3. 使用 `subprocess.check_output` 执行。<br>

<br>4. 返回解码后的字符串 (strip 去除首尾空格)。<br>

<br>5. 捕获异常并记录 Error 日志。 |
| **`get_connected_devices`** | 无 | **[设备检查]** 执行 `adb devices`，返回当前连接的设备 ID 列表。用于自动识别 `device_id`。 |

#### B. 输入法管理 (Input Method / IME)

*解决自动化测试中最大的痛点：Appium 键盘无法输入中文或遮挡 UI，系统键盘又会弹出来。*

| 函数名 | 参数 | 逻辑说明 (Vibe Coding Prompt) |
| --- | --- | --- |
| **`list_available_imes`** | 无 | 执行 `adb shell ime list -a`，返回所有安装的输入法 ID 列表。 |
| **`get_current_ime`** | 无 | 执行 `adb shell settings get secure default_input_method`，返回当前正在使用的输入法 ID。 |
| **`set_ime`** | `ime_id` | 执行 `adb shell ime set {ime_id}`。用于在 Appium UnicodeKeyboard (隐形/支持中文) 和 系统键盘 (如 Gboard/搜狗) 之间切换。 |
| **`enable_ime`** | `ime_id` | 执行 `adb shell ime enable {ime_id}`。确保输入法已启用。 |

#### C. 应用管理 (App Management)

*比 Appium Driver 更彻底的清理方式。*

| 函数名 | 参数 | 逻辑说明 (Vibe Coding Prompt) |
| --- | --- | --- |
| **`clear_app_data`** | `package_name` | **[重置应用]** 执行 `adb shell pm clear {package_name}`。<br>

<br>效果：等于卸载重装，清除所有缓存、登录状态和数据库。 |
| **`stop_app`** | `package_name` | **[强杀进程]** 执行 `adb shell am force-stop {package_name}`。 |
| **`is_app_installed`** | `package_name` | 执行 `adb shell pm list packages`，判断包名是否在返回列表中。 |

#### D. 系统控制与信息 (System & Info)

| 函数名 | 参数 | 逻辑说明 (Vibe Coding Prompt) |
| --- | --- | --- |
| **`get_device_ip`** | 无 | 获取手机 Wi-Fi IP 地址 (通常用于无线调试或判断网络)。命令：`adb shell ip -f inet addr show wlan0`。 |
| **`input_text_adb`** | `text` | **[备用输入]** 执行 `adb shell input text {text}`。<br>

<br>*注意：仅支持 ASCII 字符，不支持中文，但在某些无法定位输入框的极端场景下有效。* |
| **`toggle_wifi`** | `status(bool)` | **[WiFi开关]** 执行 `adb shell svc wifi enable` 或 `disable`。 |
| **`screen_record`** | `filename`, `duration` | **[录屏]** 执行 `adb shell screenrecord --time-limit {duration} /sdcard/{filename}`。<br>

<br>结束后执行 `pull` 拉取到本地。 |



### 文件：`utils/assert_helper.py`

#### A. 软断言类 (SoftAssert Class)

*这是自动化测试中非常重要的功能。比如你要验证一个列表里的 10 个商品价格是否正确，如果用原生 assert，第 1 个错了测试就停了，你永远不知道后面 9 个对不对。软断言可以跑完 10 个，最后统一报错。*

| 方法名 | 参数 | 逻辑说明 (Vibe Coding Prompt) |
| --- | --- | --- |
| **`__init__`** | 无 | 初始化一个空列表 `self._errors = []` 用于收集错误信息。 |
| **`expect_true`** | `condition`, `msg` | **[收集错误]** 判断 `condition` 是否为 True。<br>

<br>如果是 False，**不抛出异常**，而是将 `msg` 添加到 `self._errors` 列表中，并打印 Error 日志。 |
| **`expect_equal`** | `actual`, `expected`, `msg` | **[收集错误]** 判断 `actual == expected`。<br>

<br>如果不相等，将格式化后的错误信息（"Expected A but got B..."）添加到 `self._errors`。 |
| **`assert_all`** | 无 | **[最终裁决]** 检查 `self._errors` 是否为空。<br>

<br>如果不为空，将所有收集到的错误拼接成一个长字符串，然后**抛出 AssertionError**，一次性暴露所有问题。 |

#### B. 数据结构校验 (Data Verification)

*针对列表、字典等复杂数据的断言封装。*

| 方法名 | 参数 | 逻辑说明 (Vibe Coding Prompt) |
| --- | --- | --- |
| **`assert_list_sorted`** | `data_list`, `reverse=False` | **[排序校验]**<br>

<br>1. 复制一份 `data_list` 为 `sorted_list`。<br>

<br>2. 对 `sorted_list` 进行排序 (根据 `reverse` 决定升降序)。<br>

<br>3. 断言 `data_list == sorted_list`。<br>

<br>4. 失败提示："列表未按预期排序"。 |
| **`assert_list_contains`** | `full_list`, `sub_list` | **[子集校验]**<br>

<br>验证 `sub_list` 中的所有元素是否都存在于 `full_list` 中。<br>

<br>用于验证搜索结果是否包含关键词。 |
| **`assert_dict_subset`** | `actual_dict`, `expected_dict` | **[JSON部分匹配]**<br>

<br>验证 `expected_dict` 中的 key-value 是否都在 `actual_dict` 中存在且一致。<br>

<br>*场景：接口返回了 100 个字段，UI 只显示 3 个，我们只断言这 3 个对不对，忽略其他的。* |

#### C. 常用业务断言 (Business Assertions)

*对基础 assert 的包装，增加日志记录，让报错更可读。*

| 方法名 | 参数 | 逻辑说明 (Vibe Coding Prompt) |
| --- | --- | --- |
| **`assert_text_contains`** | `full_text`, `keyword` | 判断 `keyword` 是否包含在 `full_text` 中。<br>

<br>失败时打印清晰的 Diff 日志。 |
| **`assert_not_empty`** | `value`, `msg` | 断言 `value` 不为 None 且不为空字符串/空列表。 |
| **`assert_file_exists`** | `file_path` | 判断文件是否存在（常用于验证下载功能是否成功）。 |




### 文件：`utils/cv_helper.py`

#### A. 模板匹配 (Template Matching)

*这是 CV 在自动化中最常用的功能：在屏幕截图中找到小图标的位置，算出坐标，让 Appium 去点击。*

| 方法名 | 参数 | 逻辑说明 (Vibe Coding Prompt) |
| --- | --- | --- |
| **`find_image_center`** | `target_img_path`, `source_img_path=None`, `threshold=0.8` | **[核心定位]**<br>

<br>1. 如果 `source_img_path` 为空，则从 Driver 获取当前截图（需转换为 CV2 格式）。<br>

<br>2. 读取 `target_img_path` (你要找的小图标)。<br>

<br>3. 使用 `cv2.matchTemplate` 方法 (推荐 `TM_CCOEFF_NORMED`) 进行匹配。<br>

<br>4. 获取最大匹配值的坐标。<br>

<br>5. 如果匹配度 > `threshold`，计算并返回目标图片的**中心坐标 (x, y)**；否则返回 None。 |
| **`is_image_exist`** | `target_img_path`, `threshold=0.8` | **[布尔检查]**<br>

<br>调用 `find_image_center`。<br>

<br>如果返回坐标不为 None，返回 `True`；否则返回 `False`。<br>

<br>用于断言某个图标是否显示。 |
| **`find_all_occurrences`** | `target_img_path`, `threshold=0.8` | **[多目标查找]**<br>

<br>使用 `np.where` 找出所有匹配度大于阈值的坐标点。<br>

<br>返回坐标列表 `[(x1, y1), (x2, y2)...]`。<br>

<br>场景：消消乐游戏中找出所有红色的方块。 |

#### B. 图像差异对比 (Image Comparison)

*用于“视觉断言” (Visual Assertion)，判断 UI 是否发生异常变化（如渲染错误、颜色不对）。*

| 方法名 | 参数 | 逻辑说明 (Vibe Coding Prompt) |
| --- | --- | --- |
| **`calculate_ssim`** | `img1_path`, `img2_path` | **[结构相似度]**<br>

<br>使用 `skimage.metrics.structural_similarity` (SSIM) 算法对比两张图片。<br>

<br>1. 将两张图转为灰度图。<br>

<br>2. 调整尺寸一致（如果尺寸不同）。<br>

<br>3. 返回相似度得分 (0.0 - 1.0)。<br>

<br>4. 1.0 表示完全相同。 |
| **`calculate_hist_similarity`** | `img1_path`, `img2_path` | **[直方图对比]** (备选)<br>

<br>使用 `cv2.calcHist` 计算颜色直方图。<br>

<br>用于判断两张图颜色分布是否一致（忽略位置差异）。 |

#### C. 图像预处理辅助 (Preprocessing Helpers)

*处理 Appium 截图数据与 OpenCV 格式的转换。*

| 方法名 | 参数 | 逻辑说明 (Vibe Coding Prompt) |
| --- | --- | --- |
| **`bytes_to_cv2`** | `image_bytes` | **[格式转换]**<br>

<br>接收 `driver.get_screenshot_as_png()` 返回的二进制数据。<br>

<br>使用 `np.frombuffer` 和 `cv2.imdecode` 将其直接转换为 OpenCV 图像对象。<br>

<br>**优势**：避免了“截图保存到硬盘 -> 再从硬盘读取”的 IO 开销，速度更快。 |
| **`crop_image`** | `image_path`, `rect` | **[裁剪]**<br>

<br>根据 `rect` (x, y, w, h) 区域裁剪图片。<br>

<br>场景：对比图片时，只想对比屏幕中间的内容，去除顶部的状态栏（时间/电量）。 |



### 文件：`utils/data_loader.py`

#### A. YAML 读取 (Configuration & Accounts)

*最常用的格式，用于读取 `config/global_config.py` 中的配置或 `data/test_accounts.yaml`。*

| 方法名 | 参数 | 逻辑说明 (Vibe Coding Prompt) |
| --- | --- | --- |
| **`load_yaml`** | `file_path` | **[基础读取]**<br>

<br>1. 接收文件路径。<br>

<br>2. 使用 `yaml.safe_load()` 打开并读取文件。<br>

<br>3. 返回 Python 字典 (Dict) 或列表 (List)。<br>

<br>4. 捕获 `FileNotFoundError` 并打印清晰的错误日志。 |
| **`get_account`** | `role` | **[业务封装]** (可选)<br>

<br>1. 专门读取 `data/test_accounts.yaml`。<br>

<br>2. 根据传入的 `role` (如 "user_vip", "user_normal") 返回对应的账号密码字典。<br>

<br>3. 避免在测试用例里写死路径。 |

#### B. Excel 读取 (Batch Test Data)

*这是测试用例参数化的主力。比如测试登录接口的 20 种异常情况。*

| 方法名 | 参数 | 逻辑说明 (Vibe Coding Prompt) |
| --- | --- | --- |
| **`load_excel`** | `file_path`, `sheet_name=None` | **[核心读取]**<br>

<br>1. 使用 `openpyxl` 库打开 `.xlsx` 文件。<br>

<br>2. 如果未指定 `sheet_name`，默认读取第一个 Sheet。<br>

<br>3. **读取表头**：获取第一行的内容作为 Keys。<br>

<br>4. **读取数据**：从第二行开始遍历，将每行数据与表头映射。<br>

<br>5. **返回格式**：`[{"username": "a", "password": "1"}, {"username": "b", ...}]`。<br>

<br>这种格式最适合 `pytest.mark.parametrize`。 |

#### C. JSON/CSV 读取 (Legacy & API)

*用于读取接口 Mock 数据或简单的 CSV 数据。*

| 方法名 | 参数 | 逻辑说明 (Vibe Coding Prompt) |
| --- | --- | --- |
| **`load_json`** | `file_path` | **[JSON读取]**<br>

<br>使用 `json.load()` 读取文件并返回字典。 |
| **`load_csv`** | `file_path` | **[CSV读取]**<br>

<br>使用 Python 内置 `csv.DictReader`。<br>

<br>逻辑同 Excel，返回 List of Dicts。 |




### 文件：`utils/file_helper.py`

#### A. 路径解析 (Path Resolution)

*这是最核心的功能。不管你在哪里运行 pytest（根目录或子目录），它都能保证找到正确的文件路径。*

| 方法名 | 参数 | 逻辑说明 (Vibe Coding Prompt) |
| --- | --- | --- |
| **`get_project_root`** | 无 | **[核心锚点]**<br>

<br>1. 获取当前文件 (`utils/file_helper.py`) 的绝对路径。<br>

<br>2. 向上回溯两级 (`../../`) 找到项目根目录 `MobileAutomationFramework`。<br>

<br>3. 返回该根路径对象 (Pathlib Path)。 |
| **`join_path`** | `*args` | **[路径拼接]**<br>

<br>1. 调用 `get_project_root()` 获取根路径。<br>

<br>2. 使用 `os.path.join(root, *args)` 拼接后续路径。<br>

<br>3. **示例**：`join_path("data", "test.xlsx")` -> `/Users/xxx/MobileAuto/data/test.xlsx`。 |
| **`get_absolute_path`** | `relative_path` | **[转绝对路径]**<br>

<br>判断传入的路径是否已经是绝对路径。如果是，直接返回；如果不是，将其与 Project Root 拼接。 |

#### B. 目录维护 (Directory Maintenance)

*用于测试开始前的环境清理，和测试过程中的目录创建。*

| 方法名 | 参数 | 逻辑说明 (Vibe Coding Prompt) |
| --- | --- | --- |
| **`ensure_dir_exist`** | `path` | **[新建目录]**<br>

<br>接收一个文件夹路径。如果不存，则调用 `os.makedirs(path, exist_ok=True)` 创建它。<br>

<br>常用于创建 `logs/screenshots/`。 |
| **`clean_directory`** | `dir_path` | **[清空目录]**<br>

<br>1. 检查目录是否存在。<br>

<br>2. 遍历目录下所有文件和子文件夹。<br>

<br>3. 使用 `os.remove` 删除文件，`shutil.rmtree` 删除文件夹。<br>

<br>4. **保留根目录本身**，只清空内容。<br>

<br>常用于 `conftest.py` 启动前清空 `reports/`。 |

#### C. 文件查找与操作 (File Operations)

*辅助 Driver Factory 查找 App 安装包等。*

| 方法名 | 参数 | 逻辑说明 (Vibe Coding Prompt) |
| --- | --- | --- |
| **`find_files`** | `directory`, `extension` | **[按后缀查找]**<br>

<br>在指定目录下查找所有以 `extension` (如 `.apk` 或 `.ipa`) 结尾的文件。<br>

<br>返回文件路径列表。<br>

<br>场景：自动化查找 `apps/` 目录下的最新安装包。 |
| **`get_file_extension`** | `file_path` | 获取文件后缀名 (用于判断是 apk 还是 ipa)。 |



### 文件：`utils/logger.py`

#### A. 核心配置 (Configuration)

*初始化日志规则，决定日志存哪里、存多久、长什么样。*

| 方法名 | 参数 | 逻辑说明 (Vibe Coding Prompt) |
| --- | --- | --- |
| **`setup_logger`** | `level="INFO"` | **[初始化入口]**<br>

<br>1. 清除默认的 Handler (防止日志重复打印)。<br>

<br>2. **控制台输出**：添加 `sys.stderr`，设置格式 (带颜色)，级别默认为 INFO。<br>

<br>3. **文件输出**：调用 `_get_log_path()` 获取路径。<br>

<br>4. 配置 **Rotation** (切割)："10 MB" (每10兆切一个文件) 或 "00:00" (每天切)。<br>

<br>5. 配置 **Retention** (保留)："7 days" (只保留最近7天日志)。<br>

<br>6. 配置 **Encoding**: "utf-8" (防止中文乱码)。 |
| **`_get_log_path`** | 无 | **[路径生成]**<br>

<br>1. 使用 `utils.file_helper.get_project_root()` 获取根目录。<br>

<br>2. 拼接 `logs/` 目录。<br>

<br>3. 确保目录存在 (`os.makedirs`)。<br>

<br>4. 返回形如 `logs/runtime_{time:YYYY-MM-DD}.log` 的路径。 |

#### B. 拦截器 (Interceptor) - 选做

*Appium 和 Selenium 内部也有日志，为了统一管理，可以把它们的日志“劫持”到 Loguru 中。*

| 方法名 | 参数 | 逻辑说明 (Vibe Coding Prompt) |
| --- | --- | --- |
| **`intercept_standard_logging`** | 无 | **[接管原生日志]**<br>

<br>定义一个 `InterceptHandler` 类继承自 `logging.Handler`。<br>

<br>将 `logging.root` 的 handler 替换为这个拦截器。<br>

<br>效果：`urllib3` 或 `Appium` 内部打印的日志，也会按 Loguru 的格式输出到文件中。 |

#### C. 对外单例 (Exposed Singleton)

*不需要定义类，直接实例化一个对象供外部 import。*

| 变量名 | 类型 | 逻辑说明 (Vibe Coding Prompt) |
| --- | --- | --- |
| **`logger`** | `Object` | **[直接导出]**<br>

<br>直接 `from loguru import logger`。<br>

<br>在文件末尾执行 `setup_logger()` 进行初始化。<br>

<br>外部文件只需 `from utils.logger import logger` 即可直接使用 `logger.info()`。 |




### 文件：`utils/notify_helper.py`

#### A. 基础发送器 (Base Sender)

*负责处理 HTTP 请求，并不关心消息长什么样。*

| 方法名 | 参数 | 逻辑说明 (Vibe Coding Prompt) |
| --- | --- | --- |
| **`post_webhook`** | `url`, `headers`, `payload` | **[底层发送]**<br>

<br>1. 使用 `requests.post(url, json=payload, headers=headers)`。<br>

<br>2. 设置 `timeout=10` 防止卡死。<br>

<br>3. 捕获所有网络异常 (ConnectionError) 并记录 Error 日志，**绝对不能因为发消息失败导致测试流程报错**。 |

#### B. 模板工厂 (Template Factory)

*负责把枯燥的数据“装修”成漂亮的卡片。根据你的公司使用的 IM 工具选择实现。*

| 方法名 | 参数 | 逻辑说明 (Vibe Coding Prompt) |
| --- | --- | --- |
| **`_format_lark_card`** | `summary` (Dict) | **[飞书/Lark 卡片]**<br>

<br>1. 构造 JSON 结构 (msg_type="interactive")。<br>

<br>2. **智能标题颜色**：如果 `summary['failed'] > 0`，卡片标题背景设为红色 (Red)；否则设为绿色 (Green)。<br>

<br>3. **内容布局**：包含项目名称、运行环境、通过率、Allure 报告链接。<br>

<br>4. 返回构造好的 Dict。 |
| **`_format_dingtalk_md`** | `summary` (Dict) | **[钉钉/企微 Markdown]**<br>

<br>1. 构造 Markdown 文本。<br>

<br>2. 标题：`### UI自动化测试报告`。<br>

<br>3. 列表：`- 成功: 10`，`- 失败: 2` (字体加粗标红)。<br>

<br>4. 链接：`[查看详情](report_url)`。<br>

<br>5. 手机号：如果失败，添加 `@138xxxx` 艾特相关负责人。 |

#### C. 业务入口 (Business API)

*对外暴露的唯一方法，通常在 `conftest.py` 的 `pytest_sessionfinish` 钩子中调用。*

| 方法名 | 参数 | 逻辑说明 (Vibe Coding Prompt) |
| --- | --- | --- |
| **`send_test_report`** | `summary_data` | **[主入口]**<br>

<br>1. 从 `config/global_config.py` 或 `.env` 读取 `WEBHOOK_URL`。<br>

<br>2. 如果 URL 为空，直接 return (本地调试时不发消息)。<br>

<br>3. 调用 `_format_xxx` 生成对应平台的消息体。<br>

<br>4. 调用 `post_webhook` 发送。<br>

<br>5. 记录日志："测试报告已推送至群聊"。 |



### 文件：`utils/decorators.py`

#### A. 日志与监控 (Logging & Monitoring)

*让代码“自带解说”，不用在每个方法里写 `logger.info`。*

| 装饰器名 | 参数 | 逻辑说明 (Vibe Coding Prompt) |
| --- | --- | --- |
| **`@log_step`** | `msg=None`, `level="INFO"` | **[步骤记录器]**<br>

<br>1. 使用 `functools.wraps` 保留原函数元数据。<br>

<br>2. **入口逻辑**：如果传入了 `msg`，打印 `[STEP START] {msg}`；如果没有，打印 `[STEP START] 执行 {func_name}`。<br>

<br>3. **参数记录**：(可选) 打印函数的入参 `args` 和 `kwargs`。<br>

<br>4. **出口逻辑**：执行函数，成功后打印 `[STEP END]`。<br>

<br>5. 异常时抛出，让外层捕获。 |
| **`@time_it`** | 无 | **[耗时监控]**<br>

<br>1. 记录 `start_time = time.time()`。<br>

<br>2. 执行函数。<br>

<br>3. 记录 `end_time`。<br>

<br>4. 计算差值，打印日志：`Function {name} took {x.xx} seconds`。<br>

<br>*场景：监控“登录”或“冷启动”到底花了多久。* |

#### B. 稳定性增强 (Stability Enhancement)

*这是自动化测试中最值钱的代码，解决“网络抖动”和“渲染延迟”。*

| 装饰器名 | 参数 | 逻辑说明 (Vibe Coding Prompt) |
| --- | --- | --- |
| **`@retry`** | `max_attempts=3`, `delay=1`, `exceptions=(Exception,)` | **[自动重试]**<br>

<br>1. 开启一个 `for i in range(max_attempts)` 循环。<br>

<br>2. **Try**: 执行函数，如果成功直接 return。<br>

<br>3. **Except**: 捕获指定类型的异常。<br>

<br>   - 打印日志：`Retrying {func_name}... ({i+1}/{max})`。<br>

<br>   - `time.sleep(delay)`。<br>

<br>4. 如果循环结束仍未成功，抛出最后一次捕获的异常。<br>

<br>*场景：网络请求超时、元素暂时未加载。* |

#### C. 异常处理 (Error Handling)

*用于非关键路径的“防御性编程”。*

| 装饰器名 | 参数 | 逻辑说明 (Vibe Coding Prompt) |
| --- | --- | --- |
| **`@handle_exception`** | `default_return=None`, `screenshot=False` | **[异常吞噬]**<br>

<br>1. **Try**: 执行函数。<br>

<br>2. **Except**: 捕获所有 Exception。<br>

<br>   - 打印 Error 日志（包含堆栈信息）。<br>

<br>   - **截图逻辑**：如果 `screenshot=True`，检查函数的第一个参数 `args[0]` 是否包含 `driver` 属性（即 `self.driver`），如果有，调用截图方法。<br>

<br>   - 返回 `default_return` (如 `None` 或 `False`)。<br>

<br>*场景：关闭弹窗广告（关不掉就算了，别影响后面）。* |

#### D. 设计模式 (Design Patterns)

| 装饰器名 | 参数 | 逻辑说明 (Vibe Coding Prompt) |
| --- | --- | --- |
| **`@singleton`** | `cls` | **[单例模式]**<br>

<br>1. 定义一个字典 `_instances = {}`。<br>

<br>2. 内部函数 `get_instance`：检查 `cls` 是否在字典中。<br>

<br>3. 不在则创建并存入，在则直接返回。<br>

<br>*场景：用于 `DriverFactory` 或 `ConfigLoader`，确保全局只有一个实例。* |

